import rlh as readLikeHuman
from simpleStorageR import storeListV
import sys
# import metaStack
# import random
# this is shit. according to my fucking instinct.
# from matrixPro import generalize
# this is really weird.
# shall we use multithreading?
# from backTrans import wrapper, limiterII
from rewire import metaWrapperII
# shall we use tolist func?
# oh shit!
# randomly select the core?
# alert! max workload is fixed and therefore not negotiable.
# must select most notified shits for all.
# slow as hell.
# numpy? scipy? nltk?
d=sys.argv[1]
# it must be integer.
s = readLikeHuman.Meta(int(d))
# read the first chart.
# char count per line.
s0 = s.Meta0()
k = metaWrapperII(s0, 1, 1)
# need less conflicts with different frequencies?
# deal with the hyperparameter?
# print(k)
# print(len(k))
# must check the length first!
if len(k)>1:
    # better use a checker?
    # first level abstraction is the best.
    x = [k[0],k[-1]]
    storeListV(x,d)
    print("#"+str(d)+" succeed.")
else:
    print("#"+str(d)+" script failed to parse.")
    # what is fft? try it?
# print(x)
# use the final one?
# or use the first one?
# x0 = unpacker(x)
# print(x0)
# consider chained processor?
# need for unpacker here?
# get the highest abstraction right at the spot?
#s0v2=s.Meta0v2().tolist()
# no need to go this far.
# notice that this is the matrix.
# first let's analyze this sequence.
# generalize is a wrong choice.
# we shall take half of all matricies.
# #s1=len(s0)
# s2=limiterII(s0,5,10)
# print(s2)
# # wtf is going on?
# s1=wrapper(s0,5)
# print(s1)
# next we shall check out the nltk and nalaf. use regex to deal with this bitch.
# the brutality.