/* this script can only read from page one
 * to page two
 * therefore needs modification
 * to add up more pages
 * by passing arguments
 * */
function fucking_elimination(submarine,fucking_pattern){
var find = fucking_pattern;
var regular_fucking_expression = new RegExp(find, 'g');
// don't ya put fucking minus sign into the fucking shitty variable fucking name!
//str = str.replace(re, '');
/*console.log("--- fuck you nodejs ---");
console.log(submarine);
console.log("--- fuck you nodejs ---");
console.log(*/
	return submarine.replace(regular_fucking_expression,"");
};
//var fs = require('fs');
var content=process.argv[3];
var monarchy=process.argv.length;
if (monarchy>4){
	for (var k=4;k<monarchy;k++){
		content+=(" "+process.argv[k]);};
};
// give a test for the thing.
// how fucking long is it?
// starts from #2, and now the #2 is for pages.
// remember to write things here.  
// needs java here!
// fucking shit!
// better turn into some fucking java & python!
// motherfucking nodejs!
// better find way to cope with blanks
var p = encodeURIComponent(content);
var n=2*process.argv[2];
// we have multiplied this.
var axios = require('axios');              

var cheerio = require('cheerio');
// our brand new regexp!
// fuck you regexp!
//var patt1=new RegExp("e");
// asshole!
// we shall use this pattern.
const patt0="http://www.baidu.com/link?url=";

// we've got the brand new fucking <string_object_name>.includes(<substring_object_name>) method!
// fuck you asshole!
/*function range(size:number, startAt:number = 0):ReadonlyArray<number> {
    return [...Array(size).keys()].map(i => i + startAt);
}
function range(size, startAt) {
    return [...Array(size).keys()].map(i => i + startAt);
}
// this will only make the step equal to one.
function mobious(numberStart,numberEnd){
	var list=range(1+numberEnd-numberStart,numberStart);
	list=list.map(i => 'div[id="'+i+'"], ');
	var s="";
	for (var i = 0; i < list.length; i++) { 
  s+= list[i] ;
}
s = s.slice(0,-2);
console.log(s);
return s;
}*/
// you had better create a function to utilize the selector.
// anyway don't believe in anything magical about regex selector here.
// if you want that go for python instead or something called lua.

// use something apart from this.
// this thing is merely a improvement over the local thing.
/*/ make sure you have the real experiment.
/
fs.readFile('index.html', 'utf-8', function (err, data) {
  if (err) {
    throw err;
  }
*/
function fuckingfucked(data){
  var $ = cheerio.load(data);
// does it contain the thing?
	// fucking army!
	// i still think that little esc thing is necessary for the shit.
  $("h3[class~='t']").each(function (i, elem) {// this fucking works
	  // do not even think of other shits.
	  // save your mother fucking time.
//	  var poker = $(this).prop("tagName").toLowerCase();
//	  console.log(poker);
	  var poker=$(":first-child",$(this)).attr("href");
//	  console.log(rock);
//	  document.write(patt1.test("The best things in life are free")); 
//this is just for reference
	  try{if (poker.includes(patt0)){
	// the real thing.
		  //var rock=$(this);
		  console.log(";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;");
		  //lisp forever!
		  //console.log(poker);
		  //there must be conspirscy inside.
	console.log(fucking_elimination($(this).text(),"\n"));
		  //the mother-fucking title.
		  //ain't need no shit.
		  console.log(poker);
		  // the fucking link
		  //console.log("fuckyou");
// keep these lines in some sort of loop.
	  //try{
		  var rock=$(this).next();
// jQuery got this version of nextSibling() as next()
// this is the premise.
		  if(rock.prop("tagName").toLowerCase()=="div"){
	/*var initial=$(":first-child",$(rock.next()));
	// will this be true?
	while (initial!=undefined){
	initial=initial.next();
		console.log(initial.);
	}*/	
	  // waste of time here.
		   if (rock.attr("class").includes("c-abstract")==true)
		  {console.log(rock.text());}
		  else
		  {console.log($(":first-child",$(":first-child",$(rock)).next()).text());
			  //r u kidding me?
	//next sibling?
};}

	  else {if ($(rock).next().prop("tagName").toLowerCase()=="table"){
		  console.log($(rock).next().text());
		  // the next sibling is a table instead of the fucking style!
	//console.log($($(rock).next()).next().text());
	  };
	  
	  }
//} catch (err){// nothing serious.
//};
}// this is for that damn href error.
}catch (err){};
//for the damn selector. DO NOT REMOVE.
});
	//the key is those fucking brackets.
	//this bracket is for that filesystem module.
//});
// time to make it simple.
// i do not think that you need any kind of ads.
// simple stuff works the best.
};

// what to do next? want to process the whole thing at once? then add those fucks together!
//var data0="";
//var data1="";
//how to fetcb for the ssid?
//fuck we must use token.
axios.defaults.withCredentials = true;
//double dutch.

axios.all([                                  axios.get('http://www.baidu.com/s?pn='+n+"0"+"&word="+p,{ withCredentials: true }),                             axios.get('http://www.baidu.com/s?pn='+(n+1)+"0"+"&word="+p,{ withCredentials: true })                        ]).then(axios.spread((response1, response2) => {                              
fuckingfucked(response1.data);
	fuckingfucked(response2.data);
/*console.log(response1.data);
	console.log(response2.data);*/
	// i decide to add try-catch instead.
// this will make something.
})).catch(error => {                         console.log(error);                      });
// no need to start more requests.
// do multithreading in lua.
/*fs.readFile('index.html', 'utf-8', function (err, data) {
  if (err) {
    throw err;
  }*/
// wow this is awesome.
	// but i need a direct approach.

 
