import sqlite3

#it0, it=None, None
# render all things in vain

supertemp=(lambda fstring,strings,spliter: list(filter((lambda x:x!=fstring),strings.split(spliter))))
#wrapper=(lambda fstring,string0,spliter0: [[y for y in supertemp(fstring,k,spliter0)] for k in string0])
# this is not really recursive.
# you shall test the DEPTH first.
# use something like format and eval will do this task?
# the variable name could be weird and distinct.
# want to be recursive? check the repetitive things first.
def serious(battle):
    with open(battle,"r") as sadist:
#    global it
#    global it0
        it = supertemp("", sadist.read(),"\n")
        it0=[[y for y in supertemp("",k," ")] for k in it]
    return it, it0
# check if this works.

it,it0 = serious("SOB.log")
    # global already.
   # it =list(filter((lambda x:x!=""), sadist.read().split("\n")))
   # it0 =[[y for y in list(filter((lambda x:x!=""),k.split(" ")))] for k in it]
    # two dimentional.
state, state0=serious("faith.log")
# bullshit.
#with open("faith.log","r") as violence:
#    state=supertemp

print("initial commit")
print(it0)

# remember that the utmost understanding starts with the same thing.
# this is authority.
the_counter=0
strong=["racist","nazi","communism","hall","xargs","zen","xray","superman","bitch","fuck","fuck"]
def genius():
    global the_counter
    print("......nothing matters......")
    print("the separator",strong[the_counter],"----")
    the_counter+=1
    # no return.
# remember that similar objects could be detected.
# you can use different UUIDs to identify objects and create relations.
# you can also makr UUID shorter.
# something that needed to be searched separately, independent from contents (usually repeated content or something general like menu or index)
#sql = ("CREATE INDEX index0 ON subdir (pos);")

#sql0 = ("CREATE INDEX index1 ON subdir (uuid);")

#sql1 = ("CREATE INDEX index2 ON subdir (depth);")

conn=sqlite3.connect("fuckyou.db")

#conn.execute(sql0)
#conn.execute(sql)
# the constraints works well.

# you could use another identifier instead of POS symbols, but that's another story.
cursor=conn.execute("SELECT * FROM subdir;")

blitz=[]

for a in cursor:
    print("-----separator-----")
    print(a)
    blitz.append(a[1:])
    # uuid name pos pi si ssi wi
    # it is actually a tuple.
"""    for b in a:
        print(b)"""
# just about everything here.
# rape people off and get paid for it.
conn.commit()
conn.close()

#genius()

# normal summarization.
# useless prank.
pranker=(lambda number,blitzer: set([ blitzer[i][number] for i in range(len(blitzer))]))
#blitz0=set( [blitz[i][2] for i in range(len(blitz))  ] )
blitz0=pranker(2,blitz)
#genius()
#blitz1=set( [blitz[i][1] for i in range(len(blitz))  ] )
blitz1=pranker(1,blitz)
#print(blitz1)
#genius()
blitz2=pranker(3,blitz)
#blitz2=set( [blitz[i][3] for i in range(len(blitz))  ] )
#print(blitz2)
#genius()
#blitz3=set( [blitz[i][4] for i in range(len(blitz))  ] )
blitz3=pranker(4,blitz)
#print(blitz3)
#genius()
blitz4=pranker(5,blitz)
#blitz4=set( [blitz[i][5] for i in range(len(blitz))  ] )

# remember that similar objects could be detected.
# you can use different UUIDs to identify objects and create relations.
# you can also makr UUID shorter.
# something that needed to be searched separately, independent from contents (usually repeated content or something general like menu or index)
#sql = ("CREATE INDEX index0 ON subdir (pos);")

#sql0 = ("CREATE INDEX index1 ON subdir (uuid);")

#sql1 = ("CREATE INDEX index2 ON subdir (depth);")

conn=sqlite3.connect("fuckyou.db")

#conn.execute(sql0)

# remember that similar objects could be detected.
# you can use different UUIDs to identify objects and create relations.
# you can also makr UUID shorter.
# something that needed to be searched separately, independent from contents (usually repeated content or something general like menu or index)
#sql = ("CREATE INDEX index0 ON subdir (pos);")

#sql0 = ("CREATE INDEX index1 ON subdir (uuid);")

#sql1 = ("CREATE INDEX index2 ON subdir (depth);")

conn=sqlite3.connect("fuckyou.db")

#conn.execute(sql0)
print(blitz4)

#this is something.
genius()
"""blitz5=[[[y[0], y[2]] for y in blitz if y[2]==x] for x in blitz0]
print(blitz5)"""
# sentence.
genius()
blitz6=[[[y[0], y[1]] for y in blitz if y[1]==x] for x in blitz1]

print(blitz6)
# group by POS.
genius()

print(it0)
genius()
print(it0[0])
genius()

toothpaste=list(filter((lambda x: x[1] in it0[1]),blitz))
# turns out to be a list containing the same shit.
# what is the candidate list?
# first, unsorted.
# then sorted.
# you shall add another thing onto this.
# first rule: similar things first.
# make a variable renamer
print(toothpaste)
"""
blitz7=[[[y[0], y[3]] for y in blitz if y[3]==x] for x in blitz2]
print(blitz7)
genius()
"""

"""
genius()

heuristic0=list(filter((lambda x: x[] in it0[0]),blitz))

print(heuristic0)
"""

# make a candidate list.
# special function: sorted by a silghtly modified algorithm
# non-symmetrical.
genius()

hiphop=(lambda blitzer,blitzIndexer,item,indexer: list(filter((lambda x: x[blitzIndexer] in item[indexer]),blitzer)))
#heuristic=list(filter((lambda x: x[1] in it0[0]),blitz))

heuristic=hiphop(blitz,1,it0,0)
ranger=(lambda fuckYouAsshole: range(len(fuckYouAsshole)))
# I hate this world.
print(heuristic)
genius()
for f in ranger(state0):
    state1=hiphop(blitz,1,state0,f)
    print(state1)
    genius()
    # shameless.
#print(state2)
# make a candidate list.
# special function: sorted by a silghtly modified algorithm
# non-symmetrical.

"""
blitz8=[[[y[0], y[4]] for y in blitz if y[4]==x] for x in blitz3]
print(blitz8)
genius()
blitz9=[[[y[0], y[5]] for y in blitz if y[5]==x] for x in blitz4]
print(blitz9)
genius()
"""
# fuck them.
# check if the rule works.
# export the uuid in case of forgotten.
#font=open("hello.log","w+")
# this will not be the problem, isn't it?
#struct=a0+"\n"+a+"\n"
#font.write(struct)
#font.close()

# from general to specific to general.
